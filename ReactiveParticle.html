<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reactive Power: The Particle Flow</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/Draggable.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #020617;
            color: #e2e8f0;
            margin: 0;
            overflow: auto;
        }
        .glass-panel {
            background: rgba(15, 23, 42, 0.75);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.5s;
        }
        #main-overlay {
            pointer-events: none;
            min-height: 100vh;
            width: 100%;
        }
        #dashboard-panel, #panel-toggle-button, #concepts-panel {
            pointer-events: auto;
        }
        #dashboard-panel.minimized {
            transform: translateX(100%);
        }
        #dashboard-panel, #concepts-panel {
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(148, 163, 184, 0.4) rgba(15, 23, 42, 0.75);
        }
        #dashboard-panel::-webkit-scrollbar, #concepts-panel::-webkit-scrollbar {
            width: 8px;
        }
        #dashboard-panel::-webkit-scrollbar-track, #concepts-panel::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.75);
        }
        #dashboard-panel::-webkit-scrollbar-thumb, #concepts-panel::-webkit-scrollbar-thumb {
            background: rgba(148, 163, 184, 0.4);
            border-radius: 4px;
        }
        #dashboard-panel::-webkit-scrollbar-thumb:hover, #concepts-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(148, 163, 184, 0.8);
        }
        #webgl-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 0;
        }
        input[type="range"]{
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: .5rem;
            background: #334155;
            border-radius: 9999px;
            outline: none;
            transition: opacity .2s;
        }
        input[type="range"]::-webkit-slider-thumb,
        input[type="range"]::-moz-range-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #fff;
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid;
            transition: background .2s;
        }
        #pfSlider::-webkit-slider-thumb { border-color: #38bdf8; }
        #pfSlider::-moz-range-thumb { border-color: #38bdf8; }
        .label-3d {
            position: fixed;
            color: white;
            background: rgba(0,0,0,.6);
            padding: 4px 10px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            user-select: none;
            transition: opacity .3s;
            transform: translate(-50%,-50%);
            opacity: 0;
        }
        .control-button {
            background-color: rgba(71,85,105,.6);
            border: 1px solid rgba(148,163,184,.4);
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 500;
            border-radius: .375rem;
            transition: background-color .2s;
        }
        .control-button.active, .control-button:hover {
            background-color: rgba(59,130,246,.7);
            border-color: rgba(96,165,250,.8);
        }
        .tooltip-container {
            position: relative;
            display: inline-flex;
            align-items: center;
            cursor: help;
        }
        .tooltip-icon {
            font-style: normal;
            font-weight: bold;
            color: #94a3b8;
            border: 1px solid #94a3b8;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 10px;
            line-height: 14px;
            text-align: center;
            margin-left: 6px;
        }
        .tooltip-container .tooltip-text {
            visibility: hidden;
            width: 220px;
            background-color: #1e293b;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 10;
            bottom: 125%;
            left: 50%;
            margin-left: -110px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            font-size: 12px;
            font-weight: 400;
        }
        .tooltip-container .tooltip-text.visible {
            visibility: visible;
            opacity: 1;
        }
        .pf-toggle {
            position: relative;
            display: inline-block;
            width: 130px;
            height: 34px;
        }
        .pf-toggle input { display: none; }
        .pf-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #f59e0b;
            transition: .4s;
            border-radius: 34px;
        }
        .pf-toggle-slider:before {
            position: absolute;
            content: "";
            height: 26px; width: 61px;
            left: 4px; bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 34px;
        }
        input:checked + .pf-toggle-slider { background-color: #d946ef; }
        input:checked + .pf-toggle-slider:before { transform: translateX(61px); }
        .pf-toggle-label {
            color: white;
            position: absolute;
            transform: translateY(-50%);
            top: 50%;
            font-size: 12px;
            font-weight: 600;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        .pf-toggle-label.inductive { left: 12px; }
        .pf-toggle-label.capacitive { right: 8px; }
        .equation {
            font-style: italic;
        }
        sub, sup {
            font-size: 0.7em;
        }
        footer {
            position: fixed;
            bottom: 2px;
            left: 4px;
            z-index: 10;
        }
        #webgl-container {
            cursor: grab; /* Indicate draggable interaction */
        }
        #webgl-container.dragging {
            cursor: grabbing;
        }
    </style>
</head>

<body>
    <div id="webgl-container"></div>

    <div id="label-source" class="label-3d">Source</div>
    <div id="label-load" class="label-3d">Load</div>

    <main id="main-overlay" class="relative p-4 md:p-6">
        <div class="grid grid-cols-1 lg:grid-cols-5 gap-6">

            <div class="lg:col-span-2">
                <section id="concepts-panel" class="glass-panel rounded-xl shadow-2xl flex-col p-4 md:p-6 h-full overflow-y-auto hidden">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-bold text-white">Equations & Concepts</h2>
                        <button id="close-concepts-btn" class="text-slate-400 hover:text-white text-2xl leading-none">&times;</button>
                    </div>
                    <div class="space-y-6 text-slate-300 text-sm">
                        <div>
                            <h4 class="font-semibold text-white mb-2">Core Metaphor: The Particle Flow</h4>
                            <p>The 3D animation uses particles to represent power flow. Not all power does useful work.</p>
                            <ul class="list-none space-y-2 mt-2">
                                <li class="flex items-start"><span class="inline-block w-3 h-3 rounded-sm bg-sky-400 mr-2 mt-1 flex-shrink-0"></span><span><strong class="text-slate-100">Active Power (<span class="equation">P</span>):</strong> These blue particles move directly from source to load, representing the "true" power that performs useful work.</span></li>
                                <li class="flex items-start"><span class="inline-block w-3 h-3 rounded-sm bg-amber-500 mr-2 mt-1 flex-shrink-0"></span><span><strong class="text-slate-100">Inductive Reactive Power (<span class="equation">Q</span>):</strong> This orange, turbulent flow represents energy used to create magnetic fields (e.g., in motors). It "sloshes" back and forth, doing no net work.</span></li>
                                <li class="flex items-start"><span class="inline-block w-3 h-3 rounded-sm bg-fuchsia-500 mr-2 mt-1 flex-shrink-0"></span><span><strong class="text-slate-100">Capacitive Reactive Power (<span class="equation">Q</span>):</strong> This purple turbulence represents energy stored in electric fields. Like its inductive counterpart, it also does no net work.</span></li>
                            </ul>
                        </div>
                        <div>
                            <h4 class="font-semibold text-white mb-2">The Power Triangle</h4>
                            <p>The relationship between power types is described by a right triangle, where <span class="equation">&phi;</span> is the phase angle between voltage and current.</p>
                            <div class="mt-2 space-y-2">
                                <p>Apparent Power: <span class="equation">S = V<sub>rms</sub> I<sub>rms</sub> (VA)</span></p>
                                <p>Active Power: <span class="equation">P = S cos(&phi;) (Watts)</span></p>
                                <p>Reactive Power: <span class="equation">Q = S sin(&phi;) (VAR)</span></p>
                                <p>Relationship: <span class="equation">S<sup>2</sup> = P<sup>2</sup> + Q<sup>2</sup></span></p>
                            </div>
                        </div>
                        <div>
                            <h4 class="font-semibold text-white mb-2">Instantaneous Power</h4>
                            <p>The power at any instant, <span class="equation">p(t)</span>, has two components:</p>
                            <div class="mt-2">
                                <p><span class="equation">p(t) = P(1+ cos(2&omega;t)) + Q sin(2&omega;t)</span></p>
                            </div>
                            <p class="mt-2">The Active component is always positive (delivering power), while the Reactive component averages to zero over a full cycle.</p>
                        </div>
                    </div>
                </section>
            </div>

            <div class="lg:col-span-1 pointer-events-none"></div>

            <div class="lg:col-span-2 relative">
                <section id="dashboard-panel" class="glass-panel rounded-xl shadow-2xl flex flex-col p-4 md:p-6 h-full">
                    <div class="flex justify-between items-center flex-shrink-0 mb-4">
                        <h1 class="text-xl md:text-2xl font-bold text-white">Reactive Power: The Particle Flow</h1>
                        <div class="flex items-center space-x-2">
                            <button id="toggle-concepts-btn" class="control-button">Concepts</button>
                            <button id="resetViewBtn" class="control-button">Reset</button>
                        </div>
                    </div>

                    <div id="dashboard-content" class="flex flex-col space-y-6 overflow-y-auto">
                        <div class="grid grid-cols-3 gap-2">
                            <button id="presetResistive" class="control-button">Resistive</button>
                            <button id="presetInductive" class="control-button">Inductive</button>
                            <button id="presetCapacitive" class="control-button">Capacitive</button>
                        </div>
                        <p id="analogyText" class="text-slate-400 text-sm h-16"></p>

                        <div>
                            <h3 class="font-semibold text-white mb-2">Power Triangle</h3>
                            <canvas id="triangleCanvas" class="w-full h-64 rounded-lg bg-slate-900/50 cursor-grab"></canvas>
                        </div>
                        <div>
                            <div class="flex justify-between items-center mb-2">
                                <h3 id="chart-title" class="font-semibold text-white">Waveforms</h3>
                                <div class="flex space-x-1">
                                    <button id="view-vi" class="control-button text-xs px-2 py-1">V-I</button>
                                    <button id="view-pq" class="control-button text-xs px-2 py-1 active">P-Q</button>
                                </div>
                            </div>
                            <div class="rounded-lg bg-slate-900/50 p-2">
                                <canvas id="waveformCanvas" class="w-full h-40 cursor-grab"></canvas>
                            </div>
                            <p id="waveform-caption" class="text-xs text-slate-400 mt-2 text-center h-8">Active Power (green) always delivers energy. Reactive Power (orange/purple) averages to zero, doing no net work.</p>
                        </div>

                        <div class="grid grid-cols-2 gap-x-4 gap-y-3 text-sm mb-6">
                            <div>
                                <div class="text-slate-400 tooltip-container">Power Factor<i class="tooltip-icon" role="img" aria-label="Information">i</i><span class="tooltip-text" role="tooltip">The ratio of Active Power (<span class="equation">P</span>) to Apparent Power (<span class="equation">S</span>). A value of 1.0 means all power is doing useful work. It is the cosine of the phase angle <span class="equation">&phi;</span>.</span></div>
                                <div id="pfValue" class="text-2xl font-bold text-sky-400"></div>
                            </div>
                            <div>
                                <div class="text-slate-400 tooltip-container">Active Power (<span class="equation">P</span>)<i class="tooltip-icon" role="img" aria-label="Information">i</i><span class="tooltip-text" role="tooltip">The "True Power" that is converted into useful work (e.g., heat, light, mechanical motion). Measured in Watts (W).</span></div>
                                <div id="activePowerValue" class="text-lg font-semibold text-green-400"></div>
                            </div>
                            <div>
                                <div class="text-slate-400 tooltip-container">Net Reactive (<span class="equation">Q</span>)<i class="tooltip-icon" role="img" aria-label="Information">i</i><span class="tooltip-text" role="tooltip">Energy that "sloshes" back and forth. Because its average is zero, it performs no useful work, but is needed for electric/magnetic fields. Measured in VAR.</span></div>
                                <div id="reactivePowerValue" class="text-lg font-semibold"></div>
                            </div>
                            <div>
                                <div class="text-slate-400 tooltip-container">Apparent Power (<span class="equation">S</span>)<i class="tooltip-icon" role="img" aria-label="Information">i</i><span class="tooltip-text" role="tooltip">The total power in the circuit (<span class="equation">S = (P<sup>2</sup> + Q<sup>2</sup>)<sup>1/2</sup></span>). This determines the capacity required for wires and transformers. Measured in Volt-Amperes (VA).</span></div>
                                <div id="apparentPowerValue" class="text-lg font-semibold text-white"></div>
                            </div>
                        </div>
                        <div class="space-y-6">
                            <div>
                                <label for="pfSlider" class="block mb-2 font-medium text-white">Power Factor</label>
                                <input id="pfSlider" type="range" min="0.05" max="1" value="0.707" step="0.01">
                            </div>
                            <div>
                                <label class="pf-toggle">
                                    <input type="checkbox" id="pf-type-toggle">
                                    <span class="pf-toggle-slider"></span>
                                    <span class="pf-toggle-label inductive">Inductive</span>
                                    <span class="pf-toggle-label capacitive">Capacitive</span>
                                </label>
                            </div>
                        </div>
                    </div>
                </section>
                <button id="panel-toggle-button" class="fixed top-6 right-6 z-50 control-button p-2">
                    <svg id="toggle-icon-minus" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-dash-lg" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M2 8a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11A.5.5 0 0 1 2 8Z"/></svg>
                    <svg id="toggle-icon-plus" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrows-angle-expand hidden" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M5.828 10.172a.5.5 0 0 0-.707.707l4.096 4.096V11.5a.5.5 0 0 0 1 0v3.975a.5.5 0 0 0-.5.5H7.5a.5.5 0 0 0 0-1h2.768L5.828 10.172Zm4.344-4.344a.5.5 0 0 0 .707-.707L6.78 1.025V4.5a.5.5 0 0 0-1 0V.525a.5.5 0 0 0 .5-.5H9.5a.5.5 0 0 0 0 1H6.732l4.44 4.44Z"/></svg>
                </button>
            </div>
        </div>
        <div class="mt-8 text-slate-300 text-sm space-y-4">
            <h2 class="text-xl font-bold text-white">Additional Information</h2>
            <p>Reactive power is essential for maintaining voltage levels in AC systems, but it does not contribute to useful work.</p>
            <p>Explore how the power factor affects efficiency by adjusting the slider in the dashboard. A lower power factor indicates higher reactive power, which can strain electrical infrastructure.</p>
            <p>Understanding reactive power is crucial for engineers designing efficient power systems, as it impacts the sizing of transformers, cables, and other components.</p>
        </div>
    </main>
    <footer class="text-xs text-slate-500 pointer-events-none">Created by Babak Taheri (https://babaktaheri1.github.io/)</footer>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';

        const PARTICLE_COUNT = 80000;
        const CONDUIT_RADIUS = 4.0;
        const CONDUIT_LENGTH = 42.0;

        const COLORS = {
            REAL_POWER_3D: new THREE.Color(0x38bdf8), // Using Tailwind sky-400
            REACTIVE_LAG_3D: new THREE.Color(0xf59e0b), // amber-500
            REACTIVE_LEAD_3D: new THREE.Color(0xd946ef), // fuchsia-500
            REACTIVE_LAG_UI: '#f59e0b',
            REACTIVE_LEAD_UI: '#d946ef',
            GLASS: new THREE.Color(0.2, 0.4, 0.5),
            ACTIVE_POWER_UI: '#4ade80', // green-400
            APPARENT_POWER_UI: '#d1d5db',
            VOLTAGE_UI: '#3b82f6', // blue-500
            CURRENT_UI: '#ef4444', // red-500,
        };

        const INITIAL_STATE = {
            cameraPos: new THREE.Vector3(30, 2.5, 0),
            pf: 0.707,
            isCapacitive: false,
        };

        const ANIMATION_CONSTS = {
            AURA_SCALE_FACTOR: 0.6,
            AURA_OPACITY_FACTOR: 0.2,
            CAMERA_WOBBLE_FACTOR: 0.01
        };

        const particleVertexShader = `uniform float uTime; uniform float uTurbulence; uniform float uPowerRatio; uniform float uConduitRadius; uniform float uReactivePhase;attribute float aRandom; varying float vIsReactive;vec3 mod289(vec3 x){return x-floor(x*(1./289.))*289.;}vec4 mod289(vec4 x){return x-floor(x*(1./289.))*289.;}vec4 permute(vec4 x){return mod289(((x*34.)+1.)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-r*.85373472095314;}float snoise(vec3 v){const vec2 C=vec2(1./6.,1./3.);const vec4 D=vec4(0.,.5,1.,2.);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.,i1.z,i2.z,1.))+i.y+vec4(0.,i1.y,i2.y,1.))+i.x+vec4(0.,i1.x,i2.x,1.));float n_=.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.+1.;vec4 s1=floor(b1)*2.+1.;vec4 sh=-step(h,vec4(0.));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.);m=m*m;return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}void main(){vec3 pos=position;pos.z=mod(pos.z-uTime*5.,42.)-21.;vIsReactive=step(uPowerRatio,aRandom);float noise=snoise(vec3(pos.x*.5,pos.y*.5,pos.z*.1+uTime*.5));float initialRadius=length(position.xy);float targetRadius;vec2 displacement=vec2(0.);if(vIsReactive>.5){float realPowerRadius=uConduitRadius*sqrt(uPowerRatio);float phaseOffset=sin(uReactivePhase*3.14159265)*.5+.5;targetRadius=mix(realPowerRadius,uConduitRadius,phaseOffset*aRandom);displacement=vec2(noise*uTurbulence*3.);}else{targetRadius=initialRadius*sqrt(uPowerRatio);displacement=vec2(noise*.1);}pos.xy=normalize(pos.xy)*targetRadius+displacement;vec4 mvPosition=modelViewMatrix*vec4(pos,1.);mvPosition.y+=2.5;gl_PointSize=(30./-mvPosition.z)*(1.+aRandom);gl_Position=projectionMatrix*mvPosition;}`;
        const particleFragmentShader = `uniform vec3 uRealColor; uniform vec3 uReactiveLagColor; uniform vec3 uReactiveLeadColor; uniform float uReactiveType; varying float vIsReactive;void main() { float dist = length(gl_PointCoord - vec2(0.5)); float alpha = 1.0 - smoothstep(0.45, 0.5, dist); vec3 reactiveColor = mix(uReactiveLagColor, uReactiveLeadColor, uReactiveType); vec3 finalColor = mix(uRealColor, reactiveColor, vIsReactive); gl_FragColor = vec4(finalColor, alpha * 0.8); }`;

        let renderer, scene, camera, controls, composer, particles, reactiveAura, conduit, cylinderGroup;
        let triangleCtx, waveformCtx;
        const clock = new THREE.Clock();
        const dom = {};
        let activeChart = 'pq';
        let state = {};
        let chartOffsets = { triangle: { x: 0, y: 0 }, waveform: { x: 0, y: 0 } };
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationVelocity = { x: 0, y: 0 };

        let triangleZoom = 1.0;
        let waveformZoom = 1.0;

        const S_CONSTANT = 100.0;

        function calculatePowerState() {
            const pf = parseFloat(dom.pfSlider.value);
            const isCapacitive = dom.pfTypeToggle.checked;
            const angleSign = isCapacitive ? -1 : 1;
            const netAngleRad = angleSign * Math.acos(pf);

            const p = S_CONSTANT * Math.cos(netAngleRad);
            const q_net = S_CONSTANT * Math.sin(netAngleRad);

            state = {
                S: S_CONSTANT,
                P: p,
                Q: q_net,
                PF: pf,
                netAngleRad: netAngleRad,
                qColor: q_net >= 0 ? COLORS.REACTIVE_LAG_UI : COLORS.REACTIVE_LEAD_UI
            };
        }

        function queryDOMElements() {
            const ids = [
                'webgl-container', 'pfSlider', 'pfValue', 'activePowerValue',
                'reactivePowerValue', 'apparentPowerValue', 'analogyText', 'triangleCanvas',
                'waveformCanvas', 'label-source', 'label-load', 'resetViewBtn',
                'presetResistive', 'presetInductive', 'presetCapacitive', 'chart-title',
                'view-vi', 'view-pq', 'dashboard-panel', 'panel-toggle-button',
                'toggle-icon-minus', 'toggle-icon-plus', 'pf-type-toggle', 'waveform-caption',
                'concepts-panel', 'toggle-concepts-btn', 'close-concepts-btn'
            ];
            ids.forEach(id => {
                const camelCaseId = id.replace(/-([a-z])/g, g => g[1].toUpperCase());
                dom[camelCaseId] = document.getElementById(id);
            });
        }

        function setupCanvases() {
            [dom.triangleCanvas, dom.waveformCanvas].forEach(canvas => {
                const dpr = window.devicePixelRatio || 1;
                canvas.width = canvas.clientWidth * dpr;
                canvas.height = canvas.clientHeight * dpr;
                const ctx = canvas.getContext('2d');
                ctx.scale(dpr, dpr);
            });
            triangleCtx = dom.triangleCanvas.getContext('2d');
            waveformCtx = dom.waveformCanvas.getContext('2d');
        }

        function drawCharts() {
            if (activeChart === 'pq') drawPowerWaveforms();
            else drawVIWaveforms();
            drawTriangle();
        }

        function updateDashboard() {
            dom.pfValue.textContent = state.PF.toFixed(2);
            dom.activePowerValue.textContent = `${state.P.toFixed(0)} W`;
            dom.reactivePowerValue.textContent = `${state.Q.toFixed(0)} VAR`;
            dom.apparentPowerValue.textContent = `${state.S.toFixed(0)} VA`;
            dom.reactivePowerValue.style.color = state.qColor;

            if (state.PF >= 0.98) {
                dom.analogyText.textContent = "Excellent Power Factor (Resistive). The flow is efficient, with most power doing useful work.";
            } else if (state.Q > 0) {
                dom.analogyText.textContent = `Lagging PF (Inductive). High reactive power (orange) creates turbulence, reducing useful work capacity.`;
            } else {
                dom.analogyText.textContent = `Leading PF (Capacitive). High reactive power (purple) also creates turbulence and is inefficient.`;
            }
            drawCharts();
        }

        function setupAccessibleTooltips() {
            document.querySelectorAll('.tooltip-container').forEach(container => {
                const icon = container.querySelector('.tooltip-icon');
                const tooltip = container.querySelector('.tooltip-text');
                if (!icon || !tooltip) return;
                const show = () => tooltip.classList.add('visible');
                const hide = () => tooltip.classList.remove('visible');
                ['mouseenter', 'focus'].forEach(e => icon.addEventListener(e, show));
                ['mouseleave', 'blur'].forEach(e => icon.addEventListener(e, hide));
            });
        }

        function drawTriangle() {
            const w = dom.triangleCanvas.clientWidth, h = dom.triangleCanvas.clientHeight;
            const ctx = triangleCtx;
            ctx.clearRect(0, 0, dom.triangleCanvas.width, dom.triangleCanvas.height);
            ctx.save();
            const dpr = window.devicePixelRatio || 1;
            ctx.scale(dpr, dpr);

            // Apply pan and zoom
            ctx.translate(w / 2, h / 2);
            ctx.scale(triangleZoom, triangleZoom);
            ctx.translate(-w / 2, -h / 2);
            ctx.translate(chartOffsets.triangle.x / dpr, chartOffsets.triangle.y / dpr);

            const margin = {top: 20, right: 20, bottom: 40, left: 50};
            const plotWidth = w - margin.left - margin.right;
            const plotHeight = h - margin.top - margin.bottom;

            const max_val = S_CONSTANT * 1.1;
            const p_scale = plotWidth / max_val;
            const q_scale = plotHeight / max_val;

            const originX = margin.left;
            const originY = h - margin.bottom;

            const p_len = state.P * p_scale;
            const q_len = state.Q * q_scale;

            // Draw Axes
            const axisColor = '#64748b';
            const labelColor = '#9ca3af';
            ctx.strokeStyle = axisColor;
            ctx.fillStyle = labelColor;
            ctx.lineWidth = 1 / triangleZoom;
            ctx.font = `${12 / triangleZoom}px Inter`;

            // Y-Axis (Q)
            ctx.beginPath();
            ctx.moveTo(originX, margin.top);
            ctx.lineTo(originX, originY + 4 / triangleZoom);
            ctx.stroke();
            ctx.save();
            ctx.translate(margin.left - 35 / triangleZoom, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = "center";
            ctx.fillText("Reactive Power (Q) [VAR]", 0, 0);
            ctx.restore();

            // X-Axis (P)
            ctx.beginPath();
            ctx.moveTo(originX - 4 / triangleZoom, originY);
            ctx.lineTo(w - margin.right, originY);
            ctx.stroke();
            ctx.textAlign = "center";
            ctx.fillText("Active Power (P) [W]", w / 2, h - 15 / triangleZoom);

            // Ticks
            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            ctx.fillText("0", originX - 8 / triangleZoom, originY);

            // Draw Triangle
            ctx.lineWidth = 4 / triangleZoom;
            // P
            ctx.strokeStyle = COLORS.ACTIVE_POWER_UI;
            ctx.beginPath();
            ctx.moveTo(originX, originY);
            ctx.lineTo(originX + p_len, originY);
            ctx.stroke();
            // Q
            ctx.strokeStyle = state.qColor;
            ctx.beginPath();
            ctx.moveTo(originX + p_len, originY);
            ctx.lineTo(originX + p_len, originY - q_len);
            ctx.stroke();
            // S
            ctx.strokeStyle = COLORS.APPARENT_POWER_UI;
            ctx.beginPath();
            ctx.moveTo(originX, originY);
            ctx.lineTo(originX + p_len, originY - q_len);
            ctx.stroke();

            ctx.restore();
        }

        function drawVIWaveforms() {
            const w = dom.waveformCanvas.clientWidth, h = dom.waveformCanvas.clientHeight;
            const ctx = waveformCtx;
            ctx.clearRect(0, 0, dom.waveformCanvas.width, dom.waveformCanvas.height);
            ctx.save();
            const dpr = window.devicePixelRatio || 1;
            ctx.scale(dpr, dpr);

            ctx.translate(w / 2, h / 2);
            ctx.scale(waveformZoom, waveformZoom);
            ctx.translate(-w / 2, -h / 2);
            ctx.translate(chartOffsets.waveform.x / dpr, chartOffsets.waveform.y / dpr);

            const axisMargin = 40;
            const plotWidth = w - axisMargin;
            const y_center = h / 2;
            const v_amp = h * 0.4;

            // Draw Axes
            const axisColor = '#64748b';
            const labelColor = '#9ca3af';
            ctx.strokeStyle = axisColor;
            ctx.fillStyle = labelColor;
            ctx.lineWidth = 1 / waveformZoom;
            ctx.font = `${10 / waveformZoom}px Inter`;

            ctx.beginPath();
            ctx.moveTo(axisMargin, 0); ctx.lineTo(axisMargin, h); ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(axisMargin, y_center); ctx.lineTo(w, y_center); ctx.stroke();

            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            ctx.fillText("0", axisMargin - 5, y_center);
            ctx.fillText("+Vmax", axisMargin - 5, y_center - v_amp);
            ctx.fillText("-Vmax", axisMargin - 5, y_center + v_amp);

            // Draw Waveforms
            const v_path = new Path2D(), i_path = new Path2D();
            for (let i = 0; i <= plotWidth; i++) {
                const x = i + axisMargin;
                const angle = i / plotWidth * Math.PI * 4;
                const v_y = y_center - Math.sin(angle) * v_amp;
                const i_y = y_center - Math.sin(angle - state.netAngleRad) * v_amp;
                if (i === 0) {
                    v_path.moveTo(x, v_y);
                    i_path.moveTo(x, i_y);
                } else {
                    v_path.lineTo(x, v_y);
                    i_path.lineTo(x, i_y);
                }
            }
            ctx.lineWidth = 2 / waveformZoom;
            ctx.strokeStyle = COLORS.VOLTAGE_UI; ctx.stroke(v_path);
            ctx.strokeStyle = COLORS.CURRENT_UI; ctx.stroke(i_path);

            // Legend
            ctx.font = `${12 / waveformZoom}px Inter`;
            ctx.textAlign = "left";
            ctx.textBaseline = "alphabetic";
            ctx.fillStyle = COLORS.VOLTAGE_UI; ctx.fillText("V", axisMargin + 5, 15);
            ctx.fillStyle = COLORS.CURRENT_UI; ctx.fillText("I", axisMargin + 20, 15);

            ctx.restore();
        }

        function drawPowerWaveforms() {
            const w = dom.waveformCanvas.clientWidth, h = dom.waveformCanvas.clientHeight;
            const ctx = waveformCtx;
            ctx.clearRect(0, 0, dom.waveformCanvas.width, dom.waveformCanvas.height);
            ctx.save();
            const dpr = window.devicePixelRatio || 1;
            ctx.scale(dpr, dpr);

            ctx.translate(w / 2, h / 2);
            ctx.scale(waveformZoom, waveformZoom);
            ctx.translate(-w / 2, -h / 2);
            ctx.translate(chartOffsets.waveform.x / dpr, chartOffsets.waveform.y / dpr);

            const axisMargin = 40;
            const plotWidth = w - axisMargin;
            const y_center = h / 2;
            const y_scale = (h * 0.4) / S_CONSTANT;

            // Draw Axes
            const axisColor = '#64748b';
            const labelColor = '#9ca3af';
            ctx.strokeStyle = axisColor;
            ctx.fillStyle = labelColor;
            ctx.lineWidth = 1 / waveformZoom;
            ctx.font = `${10 / waveformZoom}px Inter`;

            ctx.beginPath();
            ctx.moveTo(axisMargin, 0); ctx.lineTo(axisMargin, h); ctx.stroke();

            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            ctx.fillText("0", axisMargin - 5, y_center);
            const p_avg_y = y_center - state.P * y_scale;
            ctx.fillStyle = COLORS.ACTIVE_POWER_UI;
            ctx.fillText(state.P.toFixed(0), axisMargin - 5, p_avg_y);
            ctx.fillStyle = labelColor;
            ctx.fillText(S_CONSTANT.toFixed(0), axisMargin - 5, y_center - S_CONSTANT * y_scale);

            ctx.setLineDash([2 / waveformZoom, 3 / waveformZoom]);
            ctx.beginPath(); ctx.moveTo(axisMargin, y_center); ctx.lineTo(w, y_center); ctx.stroke();
            ctx.setLineDash([]);

            // Draw Waveforms
            const p_path = new Path2D(), q_path = new Path2D();
            for (let i = 0; i <= plotWidth; i++) {
                const x = i + axisMargin;
                const angle = i / plotWidth * Math.PI * 2;
                const p_y = y_center - (state.P * (1 - Math.cos(2 * angle))) * y_scale;
                const q_y = y_center - (-state.Q * Math.sin(2 * angle)) * y_scale;
                if (i === 0) {
                    p_path.moveTo(x, p_y);
                    q_path.moveTo(x, q_y);
                } else {
                    p_path.lineTo(x, p_y);
                    q_path.lineTo(x, q_y);
                }
            }

            ctx.fillStyle = "rgba(74, 222, 128, .2)";
            const p_fill = new Path2D(p_path); p_fill.lineTo(plotWidth + axisMargin, y_center); p_fill.lineTo(axisMargin, y_center); ctx.fill(p_fill);

            ctx.fillStyle = state.qColor + "33";
            const q_fill = new Path2D(q_path); q_fill.lineTo(plotWidth + axisMargin, y_center); q_fill.lineTo(axisMargin, y_center); ctx.fill(q_fill);

            ctx.lineWidth = 2 / waveformZoom;
            ctx.strokeStyle = state.qColor; ctx.stroke(q_path);
            ctx.strokeStyle = COLORS.ACTIVE_POWER_UI; ctx.stroke(p_path);

            ctx.strokeStyle = "#16a34a";
            ctx.lineWidth = 3 / waveformZoom;
            ctx.beginPath(); ctx.moveTo(axisMargin, p_avg_y); ctx.lineTo(w, p_avg_y); ctx.stroke();

            // Legend
            ctx.font = `${10 / waveformZoom}px Inter`;
            ctx.textAlign = "left";
            ctx.textBaseline = "alphabetic";
            ctx.fillStyle = "#16a34a"; ctx.fillText("p(avg)", axisMargin + 5, 12);
            ctx.fillStyle = COLORS.ACTIVE_POWER_UI; ctx.fillText("p(inst)", axisMargin + 55, 12);
            ctx.fillStyle = state.qColor; ctx.fillText("q(inst)", axisMargin + 110, 12);

            ctx.restore();
        }

        function createSceneObjects() {
            const starVertices = [];
            for (let i = 0; i < 20000; i++) {
                const v = new THREE.Vector3(THREE.MathUtils.randFloatSpread(2500), THREE.MathUtils.randFloatSpread(2500), THREE.MathUtils.randFloatSpread(2500));
                if (v.length() > 300) starVertices.push(v.x, v.y, v.z);
            }
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            scene.add(new THREE.Points(starGeometry, new THREE.PointsMaterial({ color: 0x666666, size: 0.8 })));

            cylinderGroup = new THREE.Group();
            scene.add(cylinderGroup);

            const conduitGeom = new THREE.CylinderGeometry(CONDUIT_RADIUS, CONDUIT_RADIUS, CONDUIT_LENGTH, 64, 1, true);
            const conduitMat = new THREE.MeshBasicMaterial({ color: COLORS.GLASS, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending, side: THREE.FrontSide });
            conduit = new THREE.Mesh(conduitGeom, conduitMat);
            conduit.rotation.x = Math.PI/2;
            conduit.position.y = 2.5;
            cylinderGroup.add(conduit);

            const auraMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0, blending: THREE.AdditiveBlending, side: THREE.BackSide });
            reactiveAura = new THREE.Mesh(new THREE.CylinderGeometry(CONDUIT_RADIUS, CONDUIT_RADIUS, 30, 32, 1, true), auraMaterial);
            reactiveAura.rotation.x = Math.PI / 2;
            reactiveAura.position.y = 2.5;
            cylinderGroup.add(reactiveAura);

            const particlesGeom = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const randoms = new Float32Array(PARTICLE_COUNT);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const r = Math.sqrt(Math.random()) * CONDUIT_RADIUS;
                const a = Math.random() * Math.PI * 2;
                positions.set([Math.cos(a) * r, Math.sin(a) * r, THREE.MathUtils.randFloatSpread(CONDUIT_LENGTH)], i * 3);
                randoms[i] = Math.random();
            }
            particlesGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particlesGeom.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

            const particlesMaterial = new THREE.ShaderMaterial({
                vertexShader: particleVertexShader, fragmentShader: particleFragmentShader,
                uniforms: {
                    uTime: { value: 0 }, uTurbulence: { value: 0 }, uPowerRatio: { value: 0 },
                    uConduitRadius: { value: CONDUIT_RADIUS }, uReactivePhase: { value: 0 },
                    uRealColor: { value: COLORS.REAL_POWER_3D }, uReactiveLagColor: { value: COLORS.REACTIVE_LAG_3D },
                    uReactiveLeadColor: { value: COLORS.REACTIVE_LEAD_3D }, uReactiveType: { value: 0 }
                },
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
            });
            particles = new THREE.Points(particlesGeom, particlesMaterial);
            cylinderGroup.add(particles);
        }

        function update3DScene() {
            if (!particles) return;
            const powerRatio = state.P / state.S;
            const turbulence = Math.abs(state.Q) / state.S;

            particles.material.uniforms.uPowerRatio.value = powerRatio;
            particles.material.uniforms.uTurbulence.value = turbulence;
            particles.material.uniforms.uReactiveType.value = state.Q >= 0 ? 0.0 : 1.0;
            reactiveAura.material.color.copy(state.Q >= 0 ? COLORS.REACTIVE_LAG_3D : COLORS.REACTIVE_LEAD_3D);
        }

        function rotateCylinder(event) {
            if (!isDragging) return;
            const mouseX = event.clientX / window.innerWidth * 2 - 1;
            const mouseY = -(event.clientY / window.innerHeight * 2 - 1);
            const deltaX = mouseX - previousMousePosition.x;
            const deltaY = mouseY - previousMousePosition.y;

            cylinderGroup.rotation.y += deltaX * 2;
            cylinderGroup.rotation.x += deltaY * 2;

            rotationVelocity.x = deltaY * 2;
            rotationVelocity.y = deltaX * 2;

            previousMousePosition = { x: mouseX, y: mouseY };
        }

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            if(particles) particles.material.uniforms.uTime.value = t;

            if (!isDragging) {
                cylinderGroup.rotation.x += rotationVelocity.x * 0.05;
                cylinderGroup.rotation.y += rotationVelocity.y * 0.05;
                rotationVelocity.x *= 0.9;
                rotationVelocity.y *= 0.9;
            }

            controls.update();
            const turbulence = Math.abs(state.Q) / S_CONSTANT;
            const reactivePhase = t * Math.PI * turbulence;
            if(particles) particles.material.uniforms.uReactivePhase.value = reactivePhase;

            const auraPulse = Math.sin(reactivePhase * 2) ** 2;
            reactiveAura.scale.setScalar(1 + auraPulse * turbulence * ANIMATION_CONSTS.AURA_SCALE_FACTOR);
            reactiveAura.material.opacity = auraPulse * turbulence * ANIMATION_CONSTS.AURA_OPACITY_FACTOR;

            const w = renderer.domElement.clientWidth, h = renderer.domElement.clientHeight;
            const sourcePos = new THREE.Vector3(0, 2.5, 20).applyMatrix4(cylinderGroup.matrixWorld).project(camera);
            dom.labelSource.style.transform = `translate(-50%, -50%) translate(${(sourcePos.x * 0.5 + 0.5) * w}px, ${(-sourcePos.y * 0.5 + 0.5) * h}px)`;
            dom.labelSource.style.opacity = sourcePos.z < 1 ? 1 : 0;

            const loadPos = new THREE.Vector3(0, 2.5, -22).applyMatrix4(cylinderGroup.matrixWorld).project(camera);
            dom.labelLoad.style.transform = `translate(-50%, -150%) translate(${(loadPos.x * 0.5 + 0.5) * w}px, ${(-loadPos.y * 0.5 + 0.5) * h}px)`;
            dom.labelLoad.style.opacity = loadPos.z < 1 ? 1 : 0;

            composer.render();
        }

        function masterUpdate() {
            calculatePowerState();
            updateDashboard();
            update3DScene();
        }

        function init() {
            queryDOMElements();
            setupCanvases();
            setupAccessibleTooltips();

            gsap.registerPlugin(Draggable);
            Draggable.create(dom.triangleCanvas, { type: "x,y", cursor: "grab", onDrag: function() { chartOffsets.triangle.x = this.x; chartOffsets.triangle.y = this.y; drawTriangle(); } });
            Draggable.create(dom.waveformCanvas, { type: "x,y", cursor: "grab", onDrag: function() { chartOffsets.waveform.x = this.x; chartOffsets.waveform.y = this.y; drawCharts(); } });

            dom.triangleCanvas.addEventListener('wheel', (event) => {
                event.preventDefault();
                const delta = event.deltaY > 0 ? 0.9 : 1.1;
                triangleZoom = Math.min(Math.max(triangleZoom * delta, 0.5), 2.0);
                drawTriangle();
            });

            dom.waveformCanvas.addEventListener('wheel', (event) => {
                event.preventDefault();
                const delta = event.deltaY > 0 ? 0.9 : 1.1;
                waveformZoom = Math.min(Math.max(waveformZoom * delta, 0.5), 2.0);
                drawCharts();
            });

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.copy(INITIAL_STATE.cameraPos);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            dom.webglContainer.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.target.set(0, 2.5, 0);
            controls.minDistance = 10;
            controls.maxDistance = 100;
            controls.enablePan = true;
            controls.panSpeed = 0.5;
            controls.rotateSpeed = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.5, 0.85));
            composer.addPass(new FilmPass(0.15, 0.025, 648, false));

            createSceneObjects();

            dom.webglContainer.addEventListener('mousedown', (event) => {
                if (event.button === 0) {
                    isDragging = true;
                    dom.webglContainer.classList.add('dragging');
                    previousMousePosition = {
                        x: event.clientX / window.innerWidth * 2 - 1,
                        y: -(event.clientY / window.innerHeight * 2 - 1)
                    };
                    controls.enabled = false;
                }
            });

            dom.webglContainer.addEventListener('mousemove', rotateCylinder);

            dom.webglContainer.addEventListener('mouseup', () => {
                isDragging = false;
                dom.webglContainer.classList.remove('dragging');
                controls.enabled = true;
            });

            dom.webglContainer.addEventListener('mouseleave', () => {
                isDragging = false;
                dom.webglContainer.classList.remove('dragging');
                controls.enabled = true;
            });

            dom.webglContainer.addEventListener('touchstart', (event) => {
                if (event.touches.length === 1) {
                    isDragging = true;
                    dom.webglContainer.classList.add('dragging');
                    previousMousePosition = {
                        x: event.touches[0].clientX / window.innerWidth * 2 - 1,
                        y: -(event.touches[0].clientY / window.innerHeight * 2 - 1)
                    };
                    controls.enabled = false;
                }
            });

            dom.webglContainer.addEventListener('touchmove', (event) => {
                if (isDragging && event.touches.length === 1) {
                    event.preventDefault();
                    rotateCylinder({ clientX: event.touches[0].clientX, clientY: event.touches[0].clientY });
                }
            });

            dom.webglContainer.addEventListener('touchend', () => {
                isDragging = false;
                dom.webglContainer.classList.remove('dragging');
                controls.enabled = true;
            });

            dom.pfSlider.addEventListener("input", masterUpdate);
            dom.pfTypeToggle.addEventListener("change", masterUpdate);

            const handlePreset = (pf, isCapacitive) => {
                gsap.to(dom.pfSlider, { value: pf, duration: 0.7, ease: "power2.inOut", onUpdate: masterUpdate });
                dom.pfTypeToggle.checked = isCapacitive;
                masterUpdate();
            };

            dom.resetViewBtn.addEventListener("click", () => {
                controls.reset();
                gsap.to(camera.position, { ...INITIAL_STATE.cameraPos, duration: 1, ease: "power2.inOut" });
                cylinderGroup.rotation.set(0, 0, 0);
                rotationVelocity = { x: 0, y: 0 };
                handlePreset(INITIAL_STATE.pf, INITIAL_STATE.isCapacitive);

                triangleZoom = 1.0;
                waveformZoom = 1.0;
                chartOffsets.triangle.x = 0;
                chartOffsets.triangle.y = 0;
                chartOffsets.waveform.x = 0;
                chartOffsets.waveform.y = 0;

                // Redraw with reset transforms
                const draggableTriangle = Draggable.get(dom.triangleCanvas);
                const draggableWaveform = Draggable.get(dom.waveformCanvas);
                if (draggableTriangle) gsap.set(dom.triangleCanvas, {x:0, y:0});
                if (draggableWaveform) gsap.set(dom.waveformCanvas, {x:0, y:0});

                drawCharts();
            });

            dom.presetResistive.addEventListener("click", () => handlePreset(1.0, false));
            dom.presetInductive.addEventListener("click", () => handlePreset(0.707, false));
            dom.presetCapacitive.addEventListener("click", () => handlePreset(0.707, true));

            dom.panelToggleButton.addEventListener('click', () => {
                const isMinimized = dom.dashboardPanel.classList.toggle('minimized');
                dom.toggleIconMinus.classList.toggle('hidden', isMinimized);
                dom.toggleIconPlus.classList.toggle('hidden', !isMinimized);
            });

            dom.toggleConceptsBtn.addEventListener('click', () => {
                dom.conceptsPanel.classList.toggle('hidden');
                dom.toggleConceptsBtn.classList.toggle('active');
            });
            dom.closeConceptsBtn.addEventListener('click', () => {
                dom.conceptsPanel.classList.add('hidden');
                dom.toggleConceptsBtn.classList.remove('active');
            });

            function setChartView(view) {
                activeChart = view;
                dom.viewVi.classList.toggle('active', view === 'vi');
                dom.viewPq.classList.toggle('active', view === 'pq');
                dom.chartTitle.textContent = view === 'vi' ? "Voltage & Current" : "Instantaneous Power";

                if (view === 'vi') {
                    dom.waveformCaption.textContent = "This shows Voltage (V) and Current (I). Their misalignment (phase shift) creates reactive power.";
                } else {
                    dom.waveformCaption.textContent = "Active Power (green) always delivers energy. Reactive Power (orange/purple) averages to zero, doing no net work.";
                }

                drawCharts();
            };
            dom.viewVi.addEventListener('click', () => setChartView('vi'));
            dom.viewPq.addEventListener('click', () => setChartView('pq'));

            window.addEventListener("resize", () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
                setupCanvases();
                masterUpdate();
            }, false);

            masterUpdate();
            animate();
        }

        init();
    </script>
</body>
</html>
